# Home Enterprise Server Setup - Advanced Tutorial

This repository details the process of building a **home enterprise-grade server** setup that utilizes **Docker**, **Kubernetes (K8s)**, **CI/CD pipelines**, **cloud integration**, and **security best practices**. This guide will help you deploy complex services like databases and message queues, as well as explore advanced tools like **Helm**, **Istio** for service mesh, and **ArgoCD** for GitOps.

This setup is designed to replicate an enterprise environment and enable the use of industry-standard practices in a home lab.

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Infrastructure Setup](#infrastructure-setup)

   * [VMware ESXi Setup](#vmware-esxi-setup)
   * [Terraform](#terraform)
3. [Docker](#docker)

   * [Dockerfile Best Practices](#dockerfile-best-practices)
   * [Building & Running Containers](#building--running-containers)
4. [Kubernetes (K8s)](#kubernetes-k8s)

   * [Setting Up Kubernetes Cluster](#setting-up-kubernetes-cluster)
   * [Deploying Applications](#deploying-applications)
   * [Monitoring and Scaling](#monitoring-and-scaling)
5. [CI/CD Pipeline](#cicd-pipeline)

   * [GitLab CI Configuration](#gitlab-ci-configuration)
   * [Deployment with Helm](#deployment-with-helm)
6. [Cloud Integration](#cloud-integration)

   * [AWS Setup with Terraform](#aws-setup-with-terraform)
7. [Security](#security)

   * [Best Practices](#best-practices)
8. [Monitoring and Logging](#monitoring-and-logging)

   * [Prometheus & Grafana](#prometheus--grafana)
   * [ELK Stack](#elk-stack)
9. [Complex Services](#complex-services)

   * [Databases](#databases)
   * [Message Queues](#message-queues)
10. [Cloud-Native Tools](#cloud-native-tools)

    * [Helm](#helm)
    * [Istio for Service Mesh](#istio-for-service-mesh)
    * [ArgoCD for GitOps](#argocd-for-gitops)
11. [Backup & Disaster Recovery](#backup--disaster-recovery)
12. [Conclusion](#conclusion)

---

## Prerequisites

Before starting, ensure you have the following installed:

* **VMware ESXi** for virtualization
* **Terraform** for infrastructure provisioning
* **Docker** for containerization
* **kubectl** and **Kubernetes** for cluster management
* **GitLab** or any CI/CD tool for automation
* **Cloud credentials** (AWS, GCP, Azure) if you plan to use cloud services
* **Helm**, **Istio**, and **ArgoCD** for advanced cloud-native tools

### Hardware Requirements:

* **2 TB storage** or more (for hosting complex services and large data)
* **16 GB RAM** (recommended 32 GB for better performance)
* **4 CPU cores** (or more for scaling)

---

## Infrastructure Setup

### VMware ESXi Setup

1. **Install VMware ESXi**: Download and install VMware ESXi from the [official site](https://www.vmware.com/products/esxi-and-esx.html).

2. **Create VMs for Kubernetes Cluster**: Provision VMs for the Kubernetes master and worker nodes.

   * Master node: Minimum 2 CPUs, 4 GB RAM.
   * Worker nodes: Minimum 1 CPU, 2 GB RAM each.

3. **Networking Setup**: Configure virtual switches (vSwitches) for proper network connectivity between VMs.

---

### Terraform

**Terraform** is used to provision and manage cloud infrastructure.

#### Example: Provisioning EC2 Instances on AWS

1. Install Terraform from the [official site](https://www.terraform.io/downloads.html).

2. **Terraform Configuration** (`main.tf`):

   ```hcl
   provider "aws" {
     region = "us-west-2"
   }

   resource "aws_instance" "web" {
     ami = "ami-0c55b159cbfafe1f0"
     instance_type = "t2.micro"
   }
   ```

3. **Provision Infrastructure**:

   ```bash
   terraform init
   terraform plan
   terraform apply
   ```

---

## Docker

### Dockerfile Best Practices

**Docker** is essential for containerizing your applications.

#### Example Dockerfile (Node.js Application)

```Dockerfile
# Stage 1: Build the application
FROM node:14 AS build
WORKDIR /app
COPY . .
RUN npm install && npm run build

# Stage 2: Create a smaller production image
FROM nginx:latest
COPY --from=build /app/build /usr/share/nginx/html
```

### Building & Running Containers

1. **Build the Docker Image**:

   ```bash
   docker build -t myapp:v1.0 .
   ```

2. **Run the Container**:

   ```bash
   docker run -p 8080:80 myapp:v1.0
   ```

---

## Kubernetes (K8s)

Kubernetes is a container orchestration platform that automates the deployment, scaling, and management of containerized applications.

### Setting Up Kubernetes Cluster

1. **Install `kubeadm` on all nodes**.

2. **Initialize the Master Node**:

   ```bash
   sudo kubeadm init --pod-network-cidr=10.244.0.0/16
   ```

3. **Configure `kubectl` on the Master Node**:

   ```bash
   mkdir -p $HOME/.kube
   sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
   sudo chown $(id -u):$(id -g) $HOME/.kube/config
   ```

4. **Join Worker Nodes** using the token generated by the master node.

---

### Deploying Applications

Create a `deployment.yaml` for your application and deploy it to Kubernetes:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
      - name: webapp
        image: nginx:latest
        ports:
        - containerPort: 80
```

```bash
kubectl apply -f webapp-deployment.yaml
```

---

## CI/CD Pipeline

### GitLab CI Configuration

Automate the process of building, testing, and deploying applications.

```yaml
stages:
  - build
  - test
  - deploy

build:
  script:
    - docker build -t myapp:$CI_COMMIT_SHA .
    - docker push myapp:$CI_COMMIT_SHA

test:
  script:
    - docker run myapp:$CI_COMMIT_SHA npm test

deploy:
  script:
    - kubectl apply -f k8s/deployment.yaml
```

### Deployment with Helm

1. **Install Helm** from the [official site](https://helm.sh/).
2. **Deploy an Application with Helm**:

   ```bash
   helm install myapp ./myapp-helm-chart
   ```

---

## Cloud Integration

### AWS Setup with Terraform

Use Terraform to provision EC2 instances, RDS databases, or even Kubernetes clusters like **EKS**.

1. **Provision AWS Infrastructure** using Terraform.
2. **Deploy applications** to AWS using Helm and Kubernetes.

---

## Security

### Best Practices

1. **Role-Based Access Control (RBAC)**: Limit access to Kubernetes resources.
2. **Pod Security Policies (PSP)**: Secure your pods by enforcing rules, like preventing privileged access.
3. **Secrets Management**: Use **Kubernetes Secrets** or a tool like **HashiCorp Vault** to manage sensitive data.
4. **TLS Encryption**: Ensure encrypted communication between microservices and applications.

---

## Monitoring and Logging

### Prometheus & Grafana

1. **Install Prometheus** for metrics collection.

   ```bash
   kubectl apply -f prometheus-operator.yaml
   ```

2. **Install Grafana** for metrics visualization.

   ```bash
   kubectl port-forward svc/grafana 3000:3000
   ```

### ELK Stack

Use **Elasticsearch**, **Logstash**, and **Kibana** for centralized logging.

---

## Complex Services

### Databases

1. **PostgreSQL**: Deploy PostgreSQL in a Kubernetes pod using Helm.

   ```bash
   helm install postgresql bitnami/postgresql
   ```

2. **MySQL**: Install MySQL using Helm.

   ```bash
   helm install mysql bitnami/mysql
   ```

### Message Queues

1. **RabbitMQ**: Deploy RabbitMQ using Helm.

   ```bash
   helm install rabbitmq bitnami/rabbitmq
   ```

2. **Apache Kafka**: Use Helm to deploy Kafka.

   ```bash
   helm install kafka bitnami/kafka
   ```

---

## Cloud-Native Tools

### Helm

Helm helps you manage Kubernetes applications by using Helm charts to define, install, and upgrade even the most complex Kubernetes applications.

1. **Install Helm**:

   ```bash
   curl https://get.helm.sh/helm-v3.7.0-linux-amd64.tar.gz | tar xz
   mv linux-amd64/helm /usr/local/bin/helm
   ```

2. **Deploy with Helm**:

   ```bash
   helm install myapp ./myapp-helm-chart
   ```

### Istio for Service Mesh

Istio is a **service mesh** that provides features like traffic management, security, and observability for microservices.

1. **Install Istio**:

   ```bash
   curl -L https://istio.io/downloadIstio | sh -
   ```

2. **Enable Istio in Kubernetes**:

   ```bash
   kubectl label namespace default istio-injection=enabled
   ```

3. **Deploy Istio-enabled application**:
   Deploy your app with Istio proxy sidecars for enhanced observability and security.

### ArgoCD for GitOps

ArgoCD is a **GitOps** tool for Kubernetes that allows you to manage deployments through Git repositories.

1. **Install ArgoCD**:

   ```bash
   kubectl create namespace argocd
   kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
   ```

2. **Access ArgoCD UI**:

   ```bash
   kubectl port-forward svc/argocd-server -n argocd 8080:443
   ```

3. **Deploy via GitOps**:
   Set up ArgoCD to automatically sync Kubernetes applications directly from a Git repository.

---

## Backup & Disaster Recovery

1. **Regular Backups**: Use tools like **Velero** to back up your Kubernetes cluster and persistent volumes.

   ```bash
   velero install --provider aws --bucket <bucket-name> --secret-file <aws-credentials-file>
   ```

2. **Offsite Backups**: Ensure offsite backup using cloud services like **AWS S3**.

---

## Conclusion

This guide provides a comprehensive walkthrough to set up a **home enterprise-grade server** with the latest tools and practices in the DevOps and cloud-native ecosystem.
